---
layout: post
title: 深度学习从入门到入土
date: 2025-01-27 11:00:00 +0000
description: 深度学习笔记
categories: AI
tags: [Research, Deep Learning]
tabs: true
---

# 1 线性神经网络
## 1.1 梯度
梯度是数学和机器学习中的一个重要概念，尤其是在优化问题和深度学习中。梯度是一个向量，表示一个函数在某一点处的方向导数，指向函数值增长最快的方向。在多变量函数中，梯度是各个偏导数组成的向量。

### 1.1.1 梯度的定义
对于一个多变量函数 $f(x_1, x_2, \dots, x_n)$，其梯度是一个向量，记作 $\nabla f$，其中每个分量是函数对相应变量的偏导数：

$$
\nabla f = \left( \frac{\partial f}{\partial x_1}, \frac{\partial f}{\partial x_2}, \dots, \frac{\partial f}{\partial x_n} \right)
$$

### 1.1.2 为什么要计算梯度
1. **优化问题**：在机器学习和深度学习中，我们通常需要最小化一个损失函数。梯度提供了函数值下降最快的方向，因此我们可以通过沿着梯度的反方向调整参数来最小化损失函数。这种方法称为梯度下降法。
2. **模型训练**：在训练神经网络时，我们通过反向传播算法计算损失函数对每个参数的梯度。然后使用这些梯度来更新模型的参数，使得模型在训练数据上的表现逐渐改善。
3. **理解和分析**：梯度可以帮助我们理解函数的行为。例如，梯度为零的点可能是函数的极小值、极大值或鞍点。这对于分析模型的收敛性和稳定性非常重要。

### 1.1.3 梯度下降法
梯度下降法是一种迭代优化算法，用于寻找函数的局部最小值。其基本步骤如下：
1. 初始化参数值。
2. 计算损失函数对参数的梯度。
3. 沿着梯度的反方向更新参数。
4. 重复步骤2和3，直到收敛。

SGD（Stochastic Gradient Descent，随机梯度下降）是一种常用的优化算法，主要用于机器学习和深度学习中的模型训练。其核心思想是通过迭代调整模型参数，最小化损失函数。

- **优点**
  - **计算效率**：每次迭代只使用一个或少量样本，计算速度快，适合大规模数据集。
  - **逃离局部最优**：随机性有助于跳出局部最优，可能找到更好的解。
- **缺点**
  - **收敛不稳定**：由于梯度估计的随机性，损失函数可能波动较大。
  - **超参数敏感**：学习率的选择对性能影响较大。
- **变体**
  - **Mini-batch Gradient Descent**：使用小批量样本计算梯度，平衡了计算效率和稳定性。
  - **Momentum**：引入动量项，加速收敛并减少震荡。
  - **Adam**：结合动量和自适应学习率，表现优异。
  - **AdamW**

### 1.1.4 例子
假设我们有一个简单的损失函数 $L(w) = (w - 3)^2$，我们希望找到使 $L(w)$ 最小的 $w$。

1. 计算梯度：$\frac{dL}{dw} = 2(w - 3)$。
2. 初始化 $w$ 的值，例如 $w = 0$。
3. 更新 $w$：$w = w - \alpha \frac{dL}{dw}$，其中 $\alpha$ 是学习率。
4. 重复更新步骤，直到 $w$ 接近3，此时 $L(w)$ 达到最小值。

通过计算和利用梯度，我们可以有效地优化模型参数，提高模型的性能。

### 1.1.5 自动求导
- 大部分时候对标量求导
- 反向传播

## 1.2 全连接层（线性层）
- 通过矩阵乘法，全连接层将`输入`特征`映射`到`输出`特征。
  全连接层的计算公式为：
  $$
  y = xW^T + b
  $$

  其中：
  - **输入矩阵 `x`**：形状为 `(batch_size, input_features)`。表示一批样本的特征；
  - **权重矩阵 `W`**：形状为 `(output_features, input_features)`。表示全连接层的权重；
  - `W^T` 是 `W` 的转置，形状为 `(input_features, output_features)`。
  - `b` 是偏置向量，形状为 `(output_features,)`。
  - **输出矩阵 `y`**：形状为 `(batch_size, output_features)`。表示一批样本的输出。

PS: 维度表示如 x = batch_size * input_features

## 1.3 SoftMax 与 交叉熵
- SoftMax是**激活函数**
- SoftMax通过同时减去最大值，保持了稳定性（转化为分子分母同时乘最大值的指数，上下不变）；
- 将 Softmax 和交叉熵损失结合在一起计算，避免单独计算 Softmax：![[Pasted image 20250110204055.png]]
- 这种方法避免了直接计算 \( \exp(o_j - \max(o_k)) \)，从而提高了数值稳定性。

- 关于`极大似然估计`的直观理解：如果把所有的所有输出的取值集合看作一个事件，那么将每个输出取到对应值的概率相乘就是这个事件发生的概率，因为“任何已经发生的事件都有其最大概率”，所以需要极大化这个事件概率，这个事件发生的概率就是似然函数，然后如何极大化似然函数，求导，令导数等于0，然后解出未知参数，这样解出的未知参数就叫做参数的似然估计值。然后根据softmax的定义，它就是每个输出取到某个值的一种映射概率，所以似然函数就是将所有输出的softmax相乘，然后**极大化似然函数等价于极小化似然函数的负对数**，那么将似然函数取负对数，根据对数函数的性质，连乘变成连加，这样得到的函数就是`交叉熵`。

- **Softmax** 和 **交叉熵损失** 是深度学习中常用的两个概念，通常一起用于分类任务。它们之间的关系非常紧密，尤其是在多分类问题中。

---

# 2 多层感知机
## 2.1 感知机

### 2.1.1 激活函数
1. 引入非线性，使神经网络能够拟合复杂函数。
2. 决定神经元的输出，控制信号传递。
3. 增强模型的表达能力。

## 2.2 欠拟合、过拟合
模型和数据规模不匹配导致的

## 2.3 权重衰退
**权重衰减**和**L2正则化**是防止模型过拟合的常用方法，本质上是相同的技术。

### 2.3.1 **L2正则化**
L2正则化通过在损失函数中加入模型权重的平方和（L2范数），限制权重的大小，防止模型过度依赖某些特征。公式如下：

$$
\text{损失函数} = \text{原始损失函数} + \frac{\lambda}{2} \sum_{i} w_i^2
$$

- $w_i$ 是模型的权重。
- $\lambda$ 是正则化强度，控制正则化项的影响。

L2正则化倾向于让权重较小且分布均匀，避免某些权重过大。

### 2.3.2 **权重衰减**
权重衰减是优化过程中直接对权重进行衰减的操作，通常与L2正则化等价。更新权重时的公式为：

$$
w_i \leftarrow w_i - \eta \left( \frac{\partial \text{损失函数}}{\partial w_i} + \lambda w_i \right)
$$

- $\eta$ 是学习率。
- $\lambda$ 是衰减系数，控制衰减强度。


权重衰减在每次更新时都会缩小权重，防止其增长过大。

### 2.3.3 总结

- **L2正则化**：在损失函数中加入权重的平方和，限制权重大小。
- **权重衰减**：在优化过程中直接缩小权重。

两者目标一致，都是通过限制权重大小来防止过拟合。

## 2.4 丢弃法

可以视为正则化

## 2.5 前向传播、反向传播和计算图

一方面，在前向传播期间计算正则项 [(4.7.5)](https://zh-v2.d2l.ai/chapter_multilayer-perceptrons/backprop.html#equation-eq-forward-s)取决于模型参数$W^{(1)}$和 $W^{(2)}$的当前值。 它们是由优化算法根据最近迭代的反向传播给出的。 另一方面，反向传播期间参数 [(4.7.11)](https://zh-v2.d2l.ai/chapter_multilayer-perceptrons/backprop.html#equation-eq-backprop-j-h)的梯度计算， 取决于由前向传播给出的隐藏变量$h$的当前值。

因此，在训练神经网络时，在初始化模型参数后， 我们交替使用前向传播和反向传播，利用反向传播给出的梯度来更新模型参数。 注意，反向传播`重复利用`前向传播中存储的中间值，以避免重复计算。 带来的影响之一是我们需要保留中间值，直到反向传播完成。 这也是训练比单纯的预测需要更多的内存（显存）的原因之一。 此外，这些中间值的大小与网络层的数量和批量的大小大致成正比。 因此，使用更大的批量来训练更深层次的网络更容易导致`内存不足`（out of memory）错误。

### 2.5.1 小结

- 前向传播在神经网络定义的计算图中按顺序计算和存储中间变量，它的顺序是从输入层到输出层。
- 反向传播按相反的顺序（从输出层到输入层）计算和存储神经网络的中间变量和参数的梯度。
- 在训练深度学习模型时，前向传播和反向传播是相互依赖的。
- 训练比预测需要更多的内存。

## 2.6 数值稳定性 + 模型初始化和激活函数

### 2.6.1 梯度消失和梯度爆炸

为了防止梯度消失或梯度爆炸，我们需要确保每层的输出和梯度在合理的范围内。通过合理的权重初始化（如 Xavier 初始化），可以保持每层的输入和输出的方差一致，从而避免梯度在反向传播过程中指数级缩小或放大。Xavier 初始化通过调整权重的分布范围，使得每层的输出和梯度保持在稳定的范围内，进而预防梯度消失和爆炸问题。

### 2.6.2 模型初始化和激活函数选择

激活函数的选择对梯度消失和梯度爆炸问题有重要影响。理想情况下，激活函数在原点附近应满足 $σ(x)≈x$，以保持梯度的稳定性。ReLU 和 Tanh 在原点附近满足这一条件，而 Sigmoid 在远离原点时梯度接近于 0，容易导致梯度消失问题。为了缓解这一问题，可以对 Sigmoid 进行线性变换（如 $4×sigmoid(x)−2$），使其在原点附近的行为更接近线性函数。然而，实际应用中更常见的做法是直接使用 ReLU 或其变体（如 Leaky ReLU、ELU），以有效避免梯度消失问题。

# 3 循环神经网络

## 3.1 序列模型

时序序列：不独立
自回归：用自己之前的数据

- 马尔可夫
- 潜变量

## 3.2 文本预处理

- 将文本作为字符串加载到内存中。
- 将字符串拆分为词元（如单词和字符）。
- 建立一个词表，将拆分的词元映射到数字索引。
- 将文本转换为数字索引序列，方便模型操作。

### 3.2.1 tokenize

下面的`tokenize`函数将文本行列表（`lines`）作为输入， 列表中的每个元素是一个文本序列（如一条文本行）。 每个文本序列又被拆分成一个词元列表，_词元_（token）是文本的基本单位。 最后，返回一个由词元列表组成的列表，其中的每个词元都是一个字符串（string）。

```python
def tokenize(lines, token='word'):  #@save
    """将文本行拆分为单词或字符词元"""
    if token == 'word':
        return [line.split() for line in lines]
    elif token == 'char':
        return [list(line) for line in lines]
    else:
        print('错误：未知词元类型：' + token)

tokens = tokenize(lines)
for i in range(11):
    print(tokens[i])
```

### 3.2.2 vocab

- vocab是`语料库`
- 训练vocab和测试vocab要一致，常见的错误是没有保持训练和测试vocab的一致性

### 3.2.3 embedding

嵌入层：词转向量
给一个词（词元）token，学习出一个长为d的向量表示它
[[NLP学习笔记]]

## 3.3 语言模型和数据集

### 3.3.1 随机采样和顺序分区

**随机采样：**
在随机采样中，每个样本都是在原始的长序列上任意捕获的子序列。 在迭代过程中，来自两个相邻的、随机的、小批量中的子序列不一定在原始序列上相邻。 对于语言建模，目标是基于到目前为止我们看到的词元来预测下一个词元， 因此标签是移位了一个词元的原始序列。

**顺序分区：**
在迭代过程中，除了对原始序列可以随机抽样外， 我们还可以保证两个相邻的小批量中的子序列在原始序列上也是相邻的。 这种策略在基于小批量的迭代过程中保留了拆分的子序列的顺序，因此称为顺序分区。

### 3.3.2 总结：

- 语言模型是自然语言处理的关键。
- 元语法通过截断相关性，为处理长序列提供了一种实用的模型。
- 长序列存在一个问题：它们很少出现或者从不出现。
- 齐普夫定律支配着单词的分布，这个分布不仅适用于一元语法，还适用于其他元语法。
- 通过拉普拉斯平滑法可以有效地处理结构丰富而频率不足的低频词词组。
- 读取长序列的主要方式是随机采样和顺序分区。在迭代过程中，后者可以保证来自两个相邻的小批量中的子序列在原始序列上也是相邻的。

## 3.4 循环神经网络

**循环神经网络**（recurrent neural networks，RNNs） 是具有隐状态的神经网络。 用于处理时序序列

### 3.4.1 网络模型公式：

- 和MLP之间差一项

---

### 3.4.2 困惑度：

交叉熵除个均值，带个指数

---

### 3.4.3 梯度裁剪：

---

### 3.4.4 总结：

## 3.5 循环神经网络代码实现

### 3.5.1 独热编码

我们每次采样的小批量数据形状是二维张量： **（批量大小，时间步数）**。 `one_hot`函数将这样一个小批量数据转换成三维张量， 张量的最后一个维度等于词表大小（`len(vocab)`）。 我们经常转换输入的维度，以便获得形状为 **（时间步数，批量大小，词表大小）** 的输出。 这将使我们能够更方便地通过最外层的维度， 一步一步地更新小批量数据的隐状态。

```python
X = torch.arange(10).reshape((2, 5))
F.one_hot(X.T, 28).shape
torch.Size([5, 2, 28])
```

1、**转置**输入数据形状的原因：在 RNN 或类似模型中，通常需要按时间步逐个处理数据。默认情况下，输入数据的形状是 `(批量大小, 时间步数)`，但这种形状不方便直接按时间步处理数据。
通过转置 `X`，可以将数据的形状从 `(批量大小, 时间步数)` 变为 `(时间步数, 批量大小)`。这样做的目的是：

- **方便按时间步处理数据**：
  - 转置后，数据的形状为 `(时间步数, 批量大小)`。
  - 这样，最外层维度是时间步数，可以直接遍历每个时间步的数据。
- **适应 RNN 的输入格式**：
  - RNN 的输入通常是一个三维张量，形状为 `(时间步数, 批量大小, 特征维度)`。
  - 转置后，可以更方便地将数据转换为这种格式。

2、**One-Hot 编码后的形状**：
在转置后，我们对 `X.T` 进行 One-Hot 编码：

```python
X_one_hot = F.one_hot(X.T, num_classes=28)
```

- `X.T` 的形状是 `(5, 2)`。
- One-Hot 编码后，`X_one_hot` 的形状变为 `(5, 2, 28)`，其中：
  - `5` 是时间步数。
  - `2` 是批量大小。
  - `28` 是词表大小。

这种形状非常适合 RNN 的输入格式，因为：

- 最外层维度是时间步数，方便按时间步逐个处理数据。
- 每个时间步的数据形状是 `(批量大小, 词表大小)`，可以直接输入到 RNN 中。

### 3.5.2 batch_size、num_steps、epoch

- `batch_size`：批次大小，训练过程中，数据通常会被划分为多个批次（batch），每个批次包含 `batch_size` 个样本。
- `num_steps`：时间步，每次取出的序列长度，也可理解为样本每次输入小批量的序列长度。在 RNN 中，序列数据是按时间步逐步处理的。`steps` 决定了 RNN 需要展开的时间步数。
- `epoch`：迭代周期

### 3.5.3 预测

以下函数通过预热期(warm-up)（使用 `prefix` 更新隐状态但不生成输出）和预测期（基于更新后的隐状态生成新字符），实现了从给定前缀生成后续字符的功能。

```python
def predict_ch8(prefix, num_preds, net, vocab, device):  #@save
    """在prefix后面生成新字符"""
    state = net.begin_state(batch_size=1, device=device)
    outputs = [vocab[prefix[0]]]
    get_input = lambda: torch.tensor([outputs[-1]], device=device).reshape((1, 1))
    for y in prefix[1:]:  # 预热期
        _, state = net(get_input(), state)
        outputs.append(vocab[y])
    for _ in range(num_preds):  # 预测num_preds步
        y, state = net(get_input(), state)
        outputs.append(int(y.argmax(dim=1).reshape(1)))
    return ''.join([vocab.idx_to_token[i] for i in outputs])
```

### 3.5.4 梯度裁剪

同3.4.3

### 3.5.5 模型定义、训练

训练模型之前，让我们定义一个函数在一个迭代周期内训练模型。

1. 序列数据的不同采样方法（随机采样和顺序分区）将导致隐状态初始化的差异。
2. 我们在更新模型参数之前裁剪梯度。 这样的操作的目的是，即使训练过程中某个点上发生了梯度爆炸，也能保证模型不会发散。
3. 我们用困惑度来评价模型。如 [8.4.4节](https://zh-v2.d2l.ai/chapter_recurrent-neural-networks/rnn.html#subsec-perplexity)所述， 这样的度量确保了不同长度的序列具有可比性。

# 4 现代循环神经网络

## 4.1 门控单元GRU

## 4.2 LSTM

和GRU效果差不多，稍微好些

## 4.3 深度循环神经网络

又往上、又往右

## 4.4 双向循环神经网络

*不适合做推理，适合做句子特征抽取*

## 4.5 机器翻译-数据处理

使用单词级词元化时的词表大小，将明显大于使用字符级词元化时的词表大小。为了缓解这一问题，我们可以将低频词元视为相同的未知词元。
为了提高计算效率，我们仍然可以通过 _截断_（truncation）和 _填充_（padding）方式实现一次只处理

一个小批量的文本序列。 假设同一个小批量中的每个序列都应该具有相同的长度`num_steps`， 那么如果文本序列的词元数目少于`num_steps`时， 我们将继续在其末尾添加特定的“\<**pad**\>”词元， 直到其长度达到`num_steps`； 反之，我们将截断文本序列时，只取其前`num_steps` 个词元， 并且丢弃剩余的词元。这样，每个文本序列将具有相同的长度， 以便以相同形状的小批量进行加载。

>[!BUG] 
>上面一行中的\<pad\>如果不加上反斜杠，会导致之后**格式不正常**显示
>目前原因未知

## 4.6 编码器Encoder、解码器Decoder

编码器一般双向的，其最后时间步的隐状态作为解码器的初始隐状态

### 4.6.1 seq2seq

用于翻译

### 4.6.2 束搜索

介于贪心和dp之间

## 4.7 注意力机制

不随意线索：非主观
随意线索：主观要做的事情

### 4.7.1 **注意力机制（Attention Mechanism）**

注意力机制是一种模拟人类注意力分配的计算方法，用于在输入数据中选择性地关注重要信息。它通过计算 **Query**、**Key** 和 **Value** 之间的关系，决定对哪些部分分配更多注意力。

>[!Note]
>算是与心理学有关

### 4.7.2  **不随意线索（Non-Volitional Cues）**

- **定义**：不随意线索是指事物本身的固有属性或特征，不需要主观干预即可获取。
- **对应注意力机制**：在注意力机制中，**Key（K）** 通常对应不随意线索，因为 Key 表示输入数据的固有特征。
- **示例**：在图像中，物体的颜色、形状等是不随意线索。

### 4.7.3 **随意线索（Volitional Cues）**

- **定义**：随意线索是主观的、有意识的选择，表示当前关注的目标或任务。
- **对应注意力机制**：在注意力机制中，**Query（Q）** 通常对应随意线索，因为 Query 表示当前需要关注的问题或目标。
- **示例**：在阅读理解任务中，问题是随意线索，因为它引导模型关注文本中的特定部分。

### 4.7.4  **Query（Q）、Key（K）、Value（V）**

- **Query（Q）**：表示当前需要关注的目标或问题（随意线索）。
- **Key（K）**：表示输入数据的固有属性或特征（不随意线索）。
- **Value（V）**：表示输入数据的实际内容或价值，通常与 Key 相关联。

注意力机制通过计算 **Query** 和 **Key** 的相似度，决定从 **Value** 中提取哪些信息。公式如下：

$$Attention(Q,K,V)=Softmax(\frac{QK^T}{\sqrt{d_k}})V$$

其中：

- $QK^T$ 计算 Query 和 Key 的相似度。
- $\sqrt{d_k}$ 是 Query 和 Key 的维度（即每个向量的长度）。是一个重要的缩放因子，用于调节点积（dot product）的大小。它的作用是防止点积的值过大，导致梯度消失或梯度爆炸问题。
- $Softmax$ 将相似度转换为权重（概率分布）。
- $V$ 是加权求和的对象。

### 4.7.5 注意力分数：

【注意力机制的本质 Self-Attention Transformer QKV矩阵】 https://www.bilibili.com/video/BV1dt4y1J7ov/?share_source=copy_web&vd_source=844d5686586c898323ef108d7a5f4a16

### 4.7.6 seq2seq结合注意力机制

seq2seq加入Attention机制的动机，在于seq2seq本身的缺陷：回忆一下，Encoder 一方面对Decoder输出RNN的hidden state作为Decoder的RNN的初始化hidden state；另一方面，Encoder只把一个句子中的最后一个时刻（word）的最后一层 当做context（上下文），与Decoder的Input之一 Embedding进行拼接，作为Decoder的另一个输入。但是最后一个时刻（word）的最后一层这一context，尽管包含了之前的time_step的信息，但也是间接的信息，而且失去了位置信息。

把最后一个时刻（word）的最后一层作为context，是不合适的，因为从道理上讲，Encoder（源语言）和Decoder（目标翻译语言）的位置最好一一对应，而不是统一拿Encoder 的 RNN的最后一个time_step的最后一层当做Decoder的RNN的输入的一部分。举个例子，在Decoder第一个位置预测bonjour的时候，不应该拿Encoder的最后一个位置的句号的输出作为context，而是应该拿第一个位置的hello的输出作为context

因此如**4.7.4节 图**所示，引入注意力机制，更全面的获取信息间关系

## 4.8 Transformer

详情见：[[论文精读笔记]] #Transformer

# 5 BERT